
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hand Gesture Particles</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; -webkit-user-select: none; user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-element { display: none; }
        
        /* --- HUD Elements --- */
        #settings-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        #settings-btn:hover { background: rgba(255, 255, 255, 0.25); transform: rotate(90deg); }

        /* Main Panel */
        #ui-container {
            position: absolute;
            top: 75px;
            right: 20px;
            z-index: 19;
            background: rgba(20, 20, 20, 0.85);
            padding: 24px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            color: white;
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 240px;
            transform-origin: top right;
            transition: all 0.4s cubic-bezier(0.19, 1, 0.22, 1);
            opacity: 0;
            transform: scale(0.9) translateY(-10px);
            pointer-events: none;
        }

        #ui-container.visible {
            opacity: 1;
            transform: scale(1) translateY(0);
            pointer-events: auto;
        }

        /* Status Pill */
        #status-pill {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            gap: 10px;
            transition: width 0.3s;
        }

        /* Gesture Hints */
        #gesture-hints {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 10;
            text-align: right;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .hint-item {
            background: rgba(0, 0, 0, 0.4);
            color: rgba(255, 255, 255, 0.8);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.05);
            opacity: 0.8;
            transform: translateX(20px);
            transition: opacity 0.3s, transform 0.3s;
            opacity: 0;
        }
        
        .hint-item.show { opacity: 0.8; transform: translateX(0); }
        .hint-item b { color: #00ffff; margin-right: 4px; }

        /* Controls Styling */
        h2 { 
            margin: 0 0 5px 0; 
            font-size: 13px; 
            text-transform: uppercase; 
            letter-spacing: 1.5px; 
            color: rgba(255,255,255,0.6);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 8px;
        }

        .control-group { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
        .button-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }

        button {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255,255,255,0.9);
            padding: 12px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        button:hover { background: rgba(255, 255, 255, 0.15); border-color: rgba(255, 255, 255, 0.3); }
        button.active { 
            background: rgba(0, 255, 255, 0.25); 
            border-color: rgba(0, 255, 255, 0.6); 
            color: #fff;
            box-shadow: 0 0 12px rgba(0, 255, 255, 0.2);
        }
        button#btn-photo { 
            border-color: rgba(255, 100, 255, 0.3); 
            background: rgba(255, 100, 255, 0.1);
        }
        button#btn-photo.active {
            background: rgba(255, 100, 255, 0.3);
            border-color: rgba(255, 100, 255, 0.8);
            box-shadow: 0 0 15px rgba(255, 100, 255, 0.3);
        }

        button#btn-sphere { grid-column: span 2; }

        input[type="color"] { 
            -webkit-appearance: none; border: none; width: 32px; height: 32px; 
            cursor: pointer; background: none; border-radius: 50%; overflow: hidden; padding: 0;
            box-shadow: 0 0 0 2px rgba(255,255,255,0.1);
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }

        .status-dot {
            width: 8px; height: 8px;
            background-color: #ff4444;
            border-radius: 50%;
            display: inline-block;
            box-shadow: 0 0 8px #ff4444;
            transition: all 0.3s;
        }
        .status-dot.active { background-color: #00ff88; box-shadow: 0 0 8px #00ff88; }
        .status-text { font-size: 12px; color: rgba(255,255,255,0.9); font-weight: 500; }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; z-index: 20; font-size: 24px; pointer-events: none;
            transition: opacity 0.5s; text-align: center; width: 80%;
            font-weight: 300; letter-spacing: 1px;
            text-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>

<div id="loading">Initializing System...<br><span style="font-size: 14px; opacity: 0.6; margin-top: 10px; display: block;">Allow camera access</span></div>

<!-- Toggle Button -->
<div id="settings-btn" onclick="toggleSettings()">‚öôÔ∏è</div>

<!-- Status Pill -->
<div id="status-pill">
    <span id="cam-status" class="status-dot"></span>
    <span id="status-msg" class="status-text">Initializing...</span>
</div>

<!-- Hidden File Input -->
<input type="file" id="image-upload" accept="image/*" style="display: none;">

<!-- Main Control Panel (Hidden by default) -->
<div id="ui-container">
    <h2>Appearance</h2>
    <div class="control-group">
        <label style="font-size: 12px; font-weight: 500; opacity: 0.8;">Theme Color</label>
        <input type="color" id="colorPicker" value="#00ffff">
    </div>

    <h2>Shape</h2>
    <div class="button-grid">
        <button onclick="setShape('sphere')" class="shape-btn active" id="btn-sphere">Sphere</button>
        <button onclick="setShape('heart')" class="shape-btn" id="btn-heart">Heart</button>
        <button onclick="setShape('flower')" class="shape-btn" id="btn-flower">Flower</button>
        <button onclick="setShape('saturn')" class="shape-btn" id="btn-saturn">Saturn</button>
        <button onclick="setShape('fireworks')" class="shape-btn" id="btn-fireworks">Galaxy</button>
        <!-- Photo Button -->
        <button onclick="triggerPhotoUpload()" class="shape-btn" id="btn-photo" style="grid-column: span 2;">üì∏ Photo</button>
    </div>
</div>

<!-- Gesture Hints -->
<div id="gesture-hints">
    <div class="hint-item" id="hint-open"><b>Open Hand</b> Repel</div>
    <div class="hint-item" id="hint-point"><b>1 Finger</b> Gentle Flow</div>
    <div class="hint-item" id="hint-fist"><b>Fist</b> Zoom In/Out</div>
    <div class="hint-item" id="hint-rotate"><b>2 Hands</b> Rotate</div>
</div>

<video id="video-element"></video>
<div id="canvas-container"></div>

<script>
    // --- Configuration ---
    const PARTICLE_COUNT = 50000;
    const PARTICLE_SIZE = 0.45; // Default for shapes
    
    // --- Global State ---
    let currentShape = 'sphere';
    let targetPositions = new Float32Array(PARTICLE_COUNT * 3);
    
    // Interaction State
    let handInteractionScale = 1.0;
    let handWorldPos = new THREE.Vector3(0, 0, 0);
    let isHandDetected = false;
    let isFist = false;
    let isPointing = false;
    let baseColor = new THREE.Color(0x00ffff);
    
    // Camera State
    let targetCameraZ = 30;
    
    // Rotation State (Two hands)
    let handRotation = 0;
    let lastHandAngle = null;

    // --- UI Logic ---
    function toggleSettings() {
        document.getElementById('ui-container').classList.toggle('visible');
    }
    
    setTimeout(() => {
        document.querySelectorAll('.hint-item').forEach((el, i) => {
            setTimeout(() => el.classList.add('show'), i * 150);
        });
    }, 2000);

    // --- Image Upload Logic ---
    function triggerPhotoUpload() {
        document.getElementById('image-upload').click();
    }

    document.getElementById('image-upload').addEventListener('change', function(e) {
        if(e.target.files && e.target.files[0]) {
            processImage(e.target.files[0]);
        }
    });

    function processImage(file) {
        const reader = new FileReader();
        reader.onload = function(event) {
            const img = new Image();
            img.onload = function() {
                // Draw to canvas to get pixel data
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Scale image such that total pixels ~ PARTICLE_COUNT
                // width * height = PARTICLE_COUNT
                const ratio = img.height / img.width;
                const targetWidth = Math.sqrt(PARTICLE_COUNT / ratio);
                const targetHeight = targetWidth * ratio;

                canvas.width = Math.floor(targetWidth);
                canvas.height = Math.floor(targetHeight);
                
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // Collect valid pixels
                const validPixels = [];
                for(let y = 0; y < canvas.height; y++) {
                    for(let x = 0; x < canvas.width; x++) {
                        const i = (y * canvas.width + x) * 4;
                        if(data[i+3] > 64) { // Alpha check
                            validPixels.push({
                                x: (x / canvas.width - 0.5) * 35, // Wider world scale
                                y: -(y / canvas.height - 0.5) * 35 * (canvas.height/canvas.width),
                                r: data[i]/255,
                                g: data[i+1]/255,
                                b: data[i+2]/255
                            });
                        }
                    }
                }
                
                if (validPixels.length === 0) return;

                // Update UI
                document.querySelectorAll('.shape-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById('btn-photo').classList.add('active');
                currentShape = 'image';
                
                // Make particles smaller and sharper for image mode for better clarity
                particles.material.size = 0.15;
                
                // Set default photo zoom to be close
                targetCameraZ = 10;
                camera.position.z = 10;

                // Map particles to pixels
                const colorAttribute = geometry.attributes.color;
                
                for(let i = 0; i < PARTICLE_COUNT; i++) {
                    const p = validPixels[i % validPixels.length];

                    targetPositions[i*3] = p.x;
                    targetPositions[i*3+1] = p.y;
                    targetPositions[i*3+2] = (Math.random() - 0.5) * 0.5; // Very flat depth for clarity

                    // Set Color
                    colorAttribute.setXYZ(i, p.r, p.g, p.b);
                }
                colorAttribute.needsUpdate = true;
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    }

    // --- Utils: Soft Texture ---
    function getSoftParticleTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        grad.addColorStop(0, 'rgba(255,255,255,1.0)');
        grad.addColorStop(0.4, 'rgba(255,255,255,0.5)');
        grad.addColorStop(1.0, 'rgba(255,255,255,0.0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 32, 32);
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    // --- Three.js Setup ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.005); // Reduced fog density
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 30;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // Particles
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3); // For Vertex Colors
    const initialPositions = new Float32Array(PARTICLE_COUNT * 3);
    
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        positions[i*3] = (Math.random() - 0.5) * 100;
        positions[i*3+1] = (Math.random() - 0.5) * 100;
        positions[i*3+2] = (Math.random() - 0.5) * 100;
        
        initialPositions[i*3] = Math.random() * 100;

        // Init colors to baseColor
        colors[i*3] = baseColor.r;
        colors[i*3+1] = baseColor.g;
        colors[i*3+2] = baseColor.b;
    }
    
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        map: getSoftParticleTexture(),
        transparent: true,
        opacity: 0.85,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        vertexColors: true, // Enable per-particle color
        sizeAttenuation: true
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- Shape Generators ---
    function generateShape(shapeType) {
        const arr = new Float32Array(PARTICLE_COUNT * 3);
        
        if (shapeType === 'sphere') {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const r = 12 * Math.cbrt(Math.random());
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                arr[i*3] = r * Math.sin(phi) * Math.cos(theta);
                arr[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                arr[i*3+2] = r * Math.cos(phi);
            }
        } 
        else if (shapeType === 'heart') {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const t = Math.random() * 2 * Math.PI;
                const r = Math.sqrt(Math.random()); 
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let z = (Math.random() - 0.5) * 10 * r; 
                const scale = 0.7 * r; 
                arr[i*3] = x * scale;
                arr[i*3+1] = y * scale + 2;
                arr[i*3+2] = z;
            }
        }
        else if (shapeType === 'flower') {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const u = Math.random() * 2 * Math.PI;
                const v = Math.random() * Math.PI;
                const r = 5 + 5 * Math.cos(4 * u) * Math.sin(v); 
                arr[i*3] = r * Math.sin(v) * Math.cos(u);
                arr[i*3+1] = r * Math.sin(v) * Math.sin(u);
                arr[i*3+2] = r * Math.cos(v);
            }
        }
        else if (shapeType === 'saturn') {
            const ringCount = Math.floor(PARTICLE_COUNT * 0.65);
            const planetCount = PARTICLE_COUNT - ringCount;
            for (let i = 0; i < planetCount; i++) {
                const r = 7;
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                arr[i*3] = r * Math.sin(phi) * Math.cos(theta);
                arr[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                arr[i*3+2] = r * Math.cos(phi);
            }
            for (let i = planetCount; i < PARTICLE_COUNT; i++) {
                const r = 10 + Math.random() * 8; 
                const theta = Math.random() * 2 * Math.PI;
                arr[i*3] = r * Math.cos(theta);
                arr[i*3+1] = (Math.random() - 0.5) * 0.4; 
                arr[i*3+2] = r * Math.sin(theta);
            }
            const tilt = 0.5;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let y = arr[i*3+1];
                let z = arr[i*3+2];
                arr[i*3+1] = y * Math.cos(tilt) - z * Math.sin(tilt);
                arr[i*3+2] = y * Math.sin(tilt) + z * Math.cos(tilt);
            }
        }
        else if (shapeType === 'fireworks') {
             for (let i = 0; i < PARTICLE_COUNT; i++) {
                const r = Math.pow(Math.random(), 0.5) * 25; 
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                const spiral = 2 * r;
                arr[i*3] = r * Math.sin(phi) * Math.cos(theta + spiral);
                arr[i*3+1] = (Math.random()-0.5) * (30 - r);
                arr[i*3+2] = r * Math.cos(phi) * Math.sin(theta + spiral);
            }
        }
        return arr;
    }

    targetPositions = generateShape('sphere');

    window.setShape = (type) => {
        currentShape = type;
        if (type !== 'image') {
            targetPositions = generateShape(type);
            // Reset Colors to baseColor
            const colorAttribute = geometry.attributes.color;
            for(let i=0; i<PARTICLE_COUNT; i++) {
                colorAttribute.setXYZ(i, baseColor.r, baseColor.g, baseColor.b);
            }
            colorAttribute.needsUpdate = true;
            // Restore size for shapes
            particles.material.size = PARTICLE_SIZE;
        }
        document.querySelectorAll('.shape-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`btn-${type}`).classList.add('active');
    };

    const colorPicker = document.getElementById('colorPicker');
    colorPicker.addEventListener('input', (e) => {
        baseColor.set(e.target.value);
        // Only update if not in photo mode
        if (currentShape !== 'image') {
            const colorAttribute = geometry.attributes.color;
            for(let i=0; i<PARTICLE_COUNT; i++) {
                colorAttribute.setXYZ(i, baseColor.r, baseColor.g, baseColor.b);
            }
            colorAttribute.needsUpdate = true;
        }
    });

    function getZPlaneWidthHeight(depth) {
        const vFOV = camera.fov * Math.PI / 180;
        const height = 2 * Math.tan(vFOV / 2) * depth;
        const width = height * camera.aspect;
        return { width, height };
    }

    // --- MediaPipe Logic ---
    const videoElement = document.getElementById('video-element');
    const statusDot = document.getElementById('cam-status');
    const statusMsg = document.getElementById('status-msg');
    
    // Logic: Tips are 8, 12, 16, 20. PIPs are 6, 10, 14, 18. Wrist 0.
    function detectIndexPointing(landmarks) {
        const wrist = landmarks[0];
        
        // Helper: distance squared
        const dSq = (p1, p2) => Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2);
        
        // Index Extention check: Tip(8) further from wrist than PIP(6)
        const indexExtended = dSq(landmarks[8], wrist) > dSq(landmarks[6], wrist);
        
        // Middle/Ring/Pinky curled check: Tip closer to wrist than PIP
        // We add a little margin for robustness
        const middleCurled = dSq(landmarks[12], wrist) < dSq(landmarks[10], wrist) * 1.2;
        const ringCurled = dSq(landmarks[16], wrist) < dSq(landmarks[14], wrist) * 1.2;
        const pinkyCurled = dSq(landmarks[20], wrist) < dSq(landmarks[18], wrist) * 1.2;
        
        return indexExtended && middleCurled && ringCurled && pinkyCurled;
    }

    function detectFist(landmarks) {
        const wrist = landmarks[0];
        let totalDist = 0;
        const tips = [8, 12, 16, 20];
        tips.forEach(idx => {
            const dx = landmarks[idx].x - wrist.x;
            const dy = landmarks[idx].y - wrist.y;
            totalDist += Math.sqrt(dx*dx + dy*dy);
        });
        const avgDist = totalDist / 4;
        const dx = landmarks[9].x - wrist.x;
        const dy = landmarks[9].y - wrist.y;
        const palmSize = Math.sqrt(dx*dx + dy*dy);
        return avgDist < palmSize * 1.2;
    }

    function onResults(results) {
        document.getElementById('loading').style.opacity = 0;

        let detected = false;
        let pinchDistance = 0;
        let separationFactor = 1.0;

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            detected = true;
            statusDot.classList.add('active');
            
            const hand1 = results.multiHandLandmarks[0];
            
            // 1. Hand Position (Palm center default, Index Tip if pointing)
            const palmX = (hand1[0].x + hand1[9].x) / 2;
            const palmY = (hand1[0].y + hand1[9].y) / 2;
            let targetX = 1.0 - palmX; 
            let targetY = palmY;

            // 2. Gesture Detection
            isFist = detectFist(hand1);
            isPointing = detectIndexPointing(hand1);

            if (isPointing) {
                // If pointing, track the Index Tip instead of palm center
                targetX = 1.0 - hand1[8].x;
                targetY = hand1[8].y;
            }

            // Map to World
            const depth = camera.position.z;
            const { width: visibleWidth, height: visibleHeight } = getZPlaneWidthHeight(depth);
            
            handWorldPos.set(
                (targetX - 0.5) * visibleWidth,
                -(targetY - 0.5) * visibleHeight,
                5
            );

            // 3. Zoom Logic (Fist)
            // Use palm size as proxy for distance from camera
            // Wrist(0) to IndexMCP(5)
            if (isFist) {
                const w = hand1[0];
                const i = hand1[5];
                const palmSize = Math.sqrt(Math.pow(w.x - i.x, 2) + Math.pow(w.y - i.y, 2));
                
                // palmSize usually 0.05 (far) to 0.3 (close)
                // Map to Camera Z: Far -> 10, Close -> 60
                // Inverted mapping: Large palm (Close) -> Zoom Out (High Z)
                // Small palm (Far) -> Zoom In (Low Z)
                
                // ADJUSTMENT: Reduce max distance to 50 to avoid fog blackout
                let targetZ = THREE.MathUtils.mapLinear(palmSize, 0.05, 0.3, 5, 50);
                targetZ = THREE.MathUtils.clamp(targetZ, 2, 50);
                
                targetCameraZ = targetZ;
            }

            // 4. Pinch (Scale) - Only if not Fist (Fist pinch is messy)
            if (!isFist) {
                const thumb1 = hand1[4];
                const index1 = hand1[8];
                const dist1 = Math.sqrt(Math.pow(thumb1.x - index1.x, 2) + Math.pow(thumb1.y - index1.y, 2));
                let scale1 = THREE.MathUtils.mapLinear(dist1, 0.02, 0.25, 0.4, 2.0);
                scale1 = THREE.MathUtils.clamp(scale1, 0.4, 3.0);
                pinchDistance = scale1;
            } else {
                pinchDistance = handInteractionScale; // Keep current scale
            }

            if (results.multiHandLandmarks.length > 1) {
                statusMsg.innerText = "Two Hands Active";
                const hand2 = results.multiHandLandmarks[1];
                
                // Double Pinch Average
                if (!isFist) {
                    const thumb2 = hand2[4];
                    const index2 = hand2[8];
                    const dist2 = Math.sqrt(Math.pow(thumb2.x - index2.x, 2) + Math.pow(thumb2.y - index2.y, 2));
                    let scale2 = THREE.MathUtils.mapLinear(dist2, 0.02, 0.25, 0.4, 2.0);
                    pinchDistance = (pinchDistance + scale2) / 2;
                }

                // Separation -> Expansion
                const wrist1 = hand1[0];
                const wrist2 = hand2[0];
                const handSeparation = Math.sqrt(Math.pow(wrist1.x - wrist2.x, 2) + Math.pow(wrist1.y - wrist2.y, 2));
                separationFactor = THREE.MathUtils.mapLinear(handSeparation, 0.2, 0.8, 1.0, 3.5);
                
                // Rotation
                const dx = (1.0 - wrist2.x) - (1.0 - wrist1.x);
                const dy = wrist2.y - wrist1.y;
                const currentAngle = Math.atan2(dy, dx);
                
                if (lastHandAngle !== null) {
                    let delta = currentAngle - lastHandAngle;
                    if (delta > Math.PI) delta -= 2 * Math.PI;
                    if (delta < -Math.PI) delta += 2 * Math.PI;
                    handRotation += delta;
                }
                lastHandAngle = currentAngle;

            } else {
                // One Hand Status
                if (isFist) statusMsg.innerText = "Gesture: Zoom";
                else if (isPointing) statusMsg.innerText = "Gesture: Gentle Flow";
                else statusMsg.innerText = "Gesture: Force Field";
                
                lastHandAngle = null;
            }
        } else {
            statusDot.classList.remove('active');
            statusMsg.innerText = "Waiting for hands...";
            lastHandAngle = null;
        }

        isHandDetected = detected;
        const targetScale = detected ? (pinchDistance * separationFactor) : 1.0;
        handInteractionScale += (targetScale - handInteractionScale) * 0.1;
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, height: 480
    });
    
    cameraUtils.start().catch(err => {
        document.getElementById('loading').innerHTML = `<div style="color:#ff5555;background:rgba(0,0,0,0.8);padding:20px;border-radius:8px;">Camera Access Denied</div>`;
    });

    // --- Animation Loop ---
    const clock = new THREE.Clock();
    
    function animate() {
        requestAnimationFrame(animate);
        
        const time = clock.getElapsedTime();
        const positionsAttr = geometry.attributes.position;
        const array = positionsAttr.array;
        
        // Physics Params
        const baseRepulsionRadius = 15.0;
        
        // Smooth Camera Zoom
        camera.position.z += (targetCameraZ - camera.position.z) * 0.1;
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const idx = i * 3;
            
            // 1. Base Target
            let tx = targetPositions[idx];
            let ty = targetPositions[idx+1];
            let tz = targetPositions[idx+2];
            
            // 2. Rotation
            if (handRotation !== 0) {
                const cosR = Math.cos(handRotation);
                const sinR = Math.sin(handRotation);
                const rx = tx * cosR - ty * sinR;
                const ry = tx * sinR + ty * cosR;
                tx = rx;
                ty = ry;
            }

            // 3. Scale
            tx *= handInteractionScale;
            ty *= handInteractionScale;
            tz *= handInteractionScale;
            
            // 4. Idle Noise
            const noise = initialPositions[idx];
            tx += Math.sin(time * 1.5 + noise) * 0.2;
            ty += Math.cos(time * 1.2 + noise) * 0.2;
            tz += Math.sin(time * 0.8 + noise) * 0.2;

            // 5. Hand Physics (Disabled if Zooming/Fist to avoid mess)
            if (isHandDetected && !isFist) {
                const dx = array[idx] - handWorldPos.x;
                const dy = array[idx+1] - handWorldPos.y;
                const dz = array[idx+2] - handWorldPos.z;
                const distSq = dx*dx + dy*dy + dz*dz;
                
                // Define Physics Mode
                let radius = baseRepulsionRadius;
                
                if (isPointing) {
                    radius = 4.0; // Small radius for gentle finger
                }

                if (distSq < radius * radius) {
                    const dist = Math.sqrt(distSq);
                    const force = (radius - dist) / radius; 
                    
                    if (isPointing) {
                        // Gentle Flow
                        const gentlePush = 0.8; 
                        array[idx] += (dx/dist) * force * gentlePush;
                        array[idx+1] += (dy/dist) * force * gentlePush;
                        array[idx+2] += (dz/dist) * force * gentlePush;
                    } else {
                        // Strong Repulsion (Open Hand)
                        const pushStrength = 2.0;
                        tx += (dx/dist) * force * pushStrength * 10;
                        ty += (dy/dist) * force * pushStrength * 10;
                        tz += (dz/dist) * force * pushStrength * 10;
                    }
                }
            }
            
            // 6. Lerp
            array[idx] += (tx - array[idx]) * 0.08;
            array[idx+1] += (ty - array[idx+1]) * 0.08;
            array[idx+2] += (tz - array[idx+2]) * 0.08;
        }
        
        positionsAttr.needsUpdate = true;
        scene.rotation.y = Math.sin(time * 0.1) * 0.1;

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();

</script>
</body>
</html>
